import gymnasium as gym
from gymnasium import spaces
import numpy as np
import random

class GoFishEnv(gym.Env):
    def __init__(self):
        # Initialize environment
        super().__init__()

        # Define action and observation spaces
        self.action_space = spaces.Discrete(13) # 13 possible ranks

        # Observations space,  multibinary used for a space of binary values
        self.observation_space = spaces.Dict({
            "agent_hand_ranks": spaces.MultiDiscrete([5]*13),
            "opponent_hand_size": spaces.Discrete(53),
            "agent_sets_completed": spaces.Discrete(14),
            "opponent_sets_completed": spaces.Discrete(14),
            "is_agent_turn": spaces.Discrete(2)
            })

        # Define game environment
        self.deck = self._init_deck()
        self.agent_hand = []
        self.opponent_hand = [] 
        self.agent_sets = [0] * 13 # Completed sets of 4 cards
        self.opponent_sets = [0] * 13
        self.turn = 0

        
    def reset(self, seed=None, options=None):
        # Reset game to default environment
        
        # Shuffle deck
        self.deck = self._init_deck()
        random.shuffle(self.deck)

        # Determine who goes first with coin flip
        coin_flip = random.randint(0, 1)
        first = 0
        if coin_flip == 1:
            first = 1

        self.agent_turn = True if first == 0 else False

            
        # Reset agent and oppponent hands
        self.agent_hand = []
        self.opponent_hand = []
        
        # Deal hands
        dealt = 0
        while dealt < 14:
            # Deal to agent first if coin flip is 0
            if coin_flip == 0:
                self.agent_hand.append(self.deck.pop())
                self.opponent_hand.append(self.deck.pop())
                dealt += 2
            else:
                self.opponent_hand.append(self.deck.pop())
                self.agent_hand.append(self.deck.pop())
                dealt += 2

        # Reset agent and opponent completed sets, turns
        self.agent_sets = [0]*13
        self.opponent_sets = [0]*13
        self.turn = 0

        # Set initial observations
        obs = self._get_observation()
        return obs, {}


    def step(self, action): # Must return observation, reward, terminated, truncated, info
        # Action is just asking do you have rank 2, 3, etc
        # Make sure agent doesn't act out of turn, go to opponent turn if they do
        if not self.agent_turn or not self._can_ask(action):
            reward = -0.1
            reason = "moved_out_of_turn" if not self.agent_turn else "invalid_action"
            
            self.agent_turn = False
            
            while self.opponent_hand and not self._check_game_over():
                # opponent_rank = random.choice(list(set(self.opponent_hand)))
                counts = [self.opponent_hand.count(r) for r in range(13)]
                opponent_rank = int(np.argmax(counts))
                success = self._process_ask(opponent_rank, player="opponent")
                self._update_sets()

                if not success:
                    # Opponent go fish
                    if self.deck:
                        self.opponent_hand.append(self.deck.pop(0))
                    break

            self.agent_turn = True
            done = self._check_game_over()

            return self._get_observation(), reward, done, False, {"reason": reason}

        reward = 0.01
        
        # Validate action
        #if not self._can_ask(action): # Illegal move
        #    reward = -1
        #    return self._get_observation(), reward, True, False, {}
            
        prev_sets = sum(self.agent_sets)
        opp_hand_prev = len(self.opponent_hand_size)
        success = self._process_ask(action, player="agent")
        self._update_sets()
        updated_sets = sum(self.agent_sets)
        new_sets = updated_sets - prev_sets
        new_cards = opp_hand_prev - len(self.opponent_hand_size)

        # Reward of 1 per new set, 0.3 per new card
        if success:
            reward += 0.3 * new_cards
        reward += 1 * new_sets
            
        # See if move ended game
        done = self._check_game_over()

        if done:
            return self._get_observation(), reward, True, False, {}

        if success: # Agent goes again if successful turn
            self.agent_turn = True
            return self._get_observation(), reward, False, False, {}

        # Discourage blind guessing
        if success and self.agent_hand.count(action) == 1:
            reward -= 0.5

        # Go fish if unsuccessful ask
        if self.deck:
            self.agent_hand.append(self.deck.pop())
            reward -= 0.05
        self.agent_turn=False

        # Opponent turn
        while self.opponent_hand and not self._check_game_over():
            # opponent_rank = random.choice(list(set(self.opponent_hand)))
            counts = [self.opponent_hand.count(r) for r in range(13)]
            opponent_rank = int(np.argmax(counts))
            success = self._process_ask(opponent_rank, player="opponent")
            self._update_sets()

            if not success:
                # Opponent go fish
                if self.deck:
                    self.opponent_hand.append(self.deck.pop(0))
                break
        self.agent_turn = True

        done = self._check_game_over()
        return self._get_observation(), reward, done, False, {}

        

    # Deck building helper function, only need ranks
    def _init_deck(self):
        return [rank for rank in range(13) for _ in range(4)]

    # Get observation helper function, 5 observations
    def _get_observation(self):
        
        # Hand vector to count ranks in hand
        hand_vector = [self.agent_hand.count(rank) for rank in range(13)]

        # Assign hand vector to hand_ranks
        obs = {
            "agent_hand_ranks": hand_vector,
            "opponent_hand_size": len(self.opponent_hand),
            "agent_sets_completed": sum(self.agent_sets),
            "opponent_sets_completed": sum(self.opponent_sets),
            "is_agent_turn": int(self.agent_turn)
            }
        
        return obs

    def _can_ask(self, rank):
        # Verify legal moves with True or False
        return rank in self.agent_hand

    def _process_ask(self, rank, player):
        # Agent or opponent asks for a rank
        # They either get those cards (True) or draw cards from deck (False)
        
        if player == "agent": # Agent Case
            asker = self.agent_hand
            target = self.opponent_hand
            
        else: # Random Opponent Case
            asker = self.opponent_hand
            target = self.agent_hand

        
        opponent_cards_of_rank = [card for card in target if card == rank]

        # Turn over all cards of rank if True
        if opponent_cards_of_rank:
            for card in opponent_cards_of_rank:
                asker.append(card)
                target.remove(card)
            return True

        else:
            if self.deck:
                draw = self.deck.pop(0)
                asker.append(draw)
            return False

    # Function to note complete sets 
    def _update_sets(self):
        # Check each index to see if set is complete, remove from hand if yes
        for rank in range(13):
            if self.agent_hand.count(rank) == 4 and self.agent_sets[rank] == 0:
                self.agent_sets[rank] = 1
                self.agent_hand = [card for card in self.agent_hand if card != rank]

        # Repeat for opponent
        for rank in range(13):
            if self.opponent_hand.count(rank) == 4 and self.opponent_sets[rank] == 0:
                self.opponent_sets[rank] = 1
                self.opponent_hand = [card for card in self.opponent_hand if card != rank]
                

    def _check_game_over(self): # True if all sets have been completed
        sets = sum(self.agent_sets) + sum(self.opponent_sets)
        return sets == 13
        
